#' Measure sensitivity to input error
#'
#' `test_s2inpars()` measures the sensitivity of transmission rate
#' estimation error to error in user-specified values of input
#' parameters. It simulates reported incidence data with fixed
#' data-generating parameters. It varies the input parameters
#' *one at a time*, and, using each parametrization, it estimates
#' the data-generating, seasonally forced transmission rate from the
#' simulated data and records the estimation error. Simulations
#' are saved as `.RData` in the directory `"./RData/s2inpars/"`.
#'
#' @details
#' 1. [make_data()] is called to simulate `nsim` reported incidence
#'    time series, with arguments:
#'
#'    * `par_list = par_list_ref`, indicating the (fixed)
#'      data-generating parameter values
#'      \ifelse{latex}{\out{$\mathbf{\theta}$}}{\ifelse{html}{\out{<b><i>&theta;</i></b>}}{theta}}.
#'    * `n = 1042`, indicating the time series length.
#'    * `with_dem_stoch = with_dem_stoch`, indicating whether the
#'      simulation should account for demographic stochasticity.
#'    * `seed = k`, where `k` is the simulation count out of `nsim`,
#'      making the result of each simulation reproducible.
#'
#' The space of input parameters is sampled by assigning a parameter
#' in `pars_to_vary` its (true) value in `par_list_ref` multiplied
#' by a scale factor in `scale_factors`, and assigning all other
#' parameters their (true) value in `par_list_ref`. The total number
#' of parametrizations considered is thus given by
#' `length(pars_to_vary) * length(scale_factors)`. For each
#' parametrization
#' \ifelse{latex}{\out{$\mathbf{\xi}$}}{\ifelse{html}{\out{<b><i>&xi;</i></b>}}{xi}}:
#' 1. [estimate_beta_S()] and [estimate_beta_SI()] are called to
#'    estimate the seasonally forced transmission rate from each
#'    simulation, with arguments:
#'
#'    * `df = df`, where `df` is the output of [make_data()],
#'      supplying the simulated reported incidence time series.
#'    * `par_list = par_list_in`, indicating the input parameter values
#'      \ifelse{latex}{\out{$\mathbf{\xi}$}}{\ifelse{html}{\out{<b><i>&xi;</i></b>}}{xi}}.
#'      There may be error in the input. In other words, the input
#'      parameter values
#'      \ifelse{latex}{\out{$\mathbf{\xi}$}}{\ifelse{html}{\out{<b><i>&xi;</i></b>}}{xi}}
#'      may differ from the data-generating parameter values
#'      \ifelse{latex}{\out{$\mathbf{\theta}$}}{\ifelse{html}{\out{<b><i>&theta;</i></b>}}{theta}}.
#'
#'    Mock (constant) birth and natural mortality time series are
#'    created internally, with `B[i] = with(par_list, hatN0 * nu * 1)`
#'    and `mu[i] = with(par_list, mu)` for all `i`.
#' 2. [stats::loess()] is called to fit a loess curve to each
#'    raw estimate of the seasonally forced transmission rate,
#'    with arguments
#'
#'    * `formula = beta ~ t` and `data = df_est`, where `df_est` is
#'      the output of [estimate_beta_S()] or [estimate_beta_SI()],
#'      indicating the time series to which the loess curve should
#'      be fit.
#'    * `span = loess_par[i] / nrow(df_est)`, indicating (roughly)
#'      the proportion of points to be weighted in local regression.
#'    * `degree = 2`, indicating that a quadratic polynomial should
#'      be fit locally.
#'    * `na.action = "na.exclude"`, indicating that missing values
#'      should be omitted in local regression but preserved in the
#'      output of [stats::predict()].
#'
#' 3. [compute_rrmse()] is called to compute the error in each
#'    loess estimate, with arguments
#'
#'    * `x = df$beta`, indicating the true value of the transmission
#'      rate at each observation time.
#'    * `y = predict(loess_fit)`, where `loess_fit` is the output
#'      of [stats::loess()], indicating the estimated value of the
#'      transmission rate at each observation time.
#'
#' @param pars_to_vary Character vector. Contains the names of all
#'   input parameters to be varied, chosen from `"S0"`, `"I0"`, `"nu"`,
#'   `"mu"`, `"tgen"`, `"prep"`, and `"trep"`.
#' @param par_list_ref A list returned by
#'   `make_par_list(..., beta_mean = NA, N0 = NA, S0 = NA, I0 = NA)`.
#'   Contains values for all data-generating parameters.
#' @param scale_factors Numeric vector. The values of `pars_to_vary[j]`
#'   considered in the analysis are given by
#'   `par_list_ref[[pars_to_vary[j]]] * scale_factors`.
#' @param with_dem_stoch Logical scalar, passed to [make_data()]. If
#'   `TRUE`, then simulations account for demographic stochasticity.
#' @param nsim Integer scalar. The number of simulations to perform.
#' @param loess_par Integer vector of length 2. Determines the degree
#'   of smoothing when loess curves are fit to raw estimates of the
#'   seasonally forced transmission rate (see Details). Estimates
#'   generated by [estimate_beta_S()] use `loess_par[1]`, while those
#'   generated by [estimate_beta_SI()] use `loess_par[2]`.
#' @param ptpi_iter Integer scalar, passed to [ptpi()]. The number of
#'   iterations desired when correcting erroneous values of `S0` using
#'   peak-to-peak iteration.
#'
#' @return
#' A numeric array with dimensions
#' `c(length(scale_factors), length(pars_to_vary), nsim, 2)`. Stores
#' the relative root mean square error (RRMSE) in each estimate of
#' the seasonally forced transmission rate. The `[i, j, k, m]`th entry
#' corresponds to simulation `k` of `nsim`, and estimate `m` of 2 from
#' that simulation using `par_vals_all[i, j]` (S method for `m = 1`,
#' SI method for `m = 2`).
#'
#' A list of the arguments of `test_s2dgbeta()` is included as an
#' attribute.
#'
#' @md
#' @export
test_s2inpars <- function(pars_to_vary   = c("tgen"),
                          par_list_ref   = make_par_list(),
                          scale_factors  = c(1),
                          with_dem_stoch = FALSE,
                          nsim           = 4L,
                          loess_par      = c(NA, NA),
                          ptpi_iter      = 0L) {

## Set-up ==============================================================

# Return to main working directory when you are done
main_wd <- getwd()
on.exit(setwd(main_wd))

# Create a directory for `.RData`, named by simulation method
dirname <- paste0(
  main_wd, "/RData/s2inpars/",
  # with or without environmental stochasticity
  if (with(par_list_ref, epsilon == 0)) "xx" else "es",
  # with or without demographic stochasticity
  if (with_dem_stoch) "ds" else "xx",
  # with or without observation error
  if (with(par_list_ref, prep == 1 && trep == 0)) "xx" else "oe",
  "/"
)
if (!dir.exists(dirname)) {
  dir.create(dirname, recursive = TRUE)
}
setwd(dirname)

# Generate the set of values considered for each parameter
# listed in `pars_to_vary`
par_vals_ref <- unlist(par_list_ref[pars_to_vary])
par_vals_all <- as.data.frame(outer(scale_factors, par_vals_ref))

# Preallocate memory for output
rrmse <- array(NA,
  dim      = c(dim(par_vals_all), nsim, 2),
  dimnames = list(NULL, colnames(par_vals_all), NULL, c("S", "SI"))
)


## Sensitivity analysis ================================================

for (par in colnames(par_vals_all)) { # loop over parameters

  for (i in 1:nrow(par_vals_all)) { # loop over parameter values

    ## Set-up ----------------------------------------------------------

    # List of values for data-generating parameters.
    # Use reference values.
    par_list_dg <- par_list_ref

    # List of values for input parameters.
    # Use reference values, except for `par`.
    par_list_in <- par_list_ref
    par_list_in[[par]] <- par_vals_all[i, par]

    ## NOTE: This introduces input error, because the input
    ##       value `par_vals_all[i, par]` will differ from
    ##       the data-generating value `par_list_ref[[par]]`
    ##       by a factor of `scale_factors[i]`.

    # Logical matrix: Have you already warned about
    # `estimate_beta_S()` or `estimate_beta_SI()` returning
    # a negative estimate of susceptibles or infecteds?
    been_neg <- array(FALSE,
      dim      = c(2, 2),
      dimnames = list(c("S", "I"), c("S", "SI"))
    )


    ## Everything else -------------------------------------------------

    for (k in 1:nsim) {

      message(
        "par ", which(colnames(par_vals_all) == par), " of ",
        ncol(par_vals_all), ", ",
        "val ", i, " of ", nrow(par_vals_all), ", ",
        "sim ", k, " of ", nsim
      )

      ## 1. Simulate data ----------------------------------------------

      filename <- paste0("sim", sprintf("%04.0f", k), ".RData")
      if (file.exists(filename)) {
        load(filename)
      } else {
        df <- make_data(
          par_list       = par_list_dg,
          n              = 20 * 365 / 7,
          with_dem_stoch = with_dem_stoch,
          seed           = k
        )
        save(df, file = filename)
      }

      ## 2. Update value of `S0` in input ... --------------------------
      ##    using peak-to-peak iteration

      if (par == "S0" && ptpi_iter > 0) {
        Z <- estimate_beta_SI(df, par_list_in)$Z
        peaks <- get_peak_times(
          x         = Z,
          period    = with(par_list_in, (365 / 7) / dt_weeks),
          bw_mavg   = 6,
          bw_peakid = 8
        )
        ptpi_out <- ptpi(
          df             = data.frame(Z),
          par_list       = par_list_in,
          a              = with(peaks, phase[1]),
          b              = with(peaks, phase[length(phase)]),
          initial_S0_est = par_list_in$S0,
          iter           = ptpi_iter
        )
        par_list_in$S0 <- ptpi_out$S0_final
      }

      ## 3. Estimate transmission rate ---------------------------------

      estimate_beta <- list(
        S  = estimate_beta_S,
        SI = estimate_beta_SI
      )
      df_est <- suppressWarnings(
        lapply(estimate_beta, function(f) f(df, par_list_in))
      )

      # Logical matrix: Did `estimate_beta_S()` or `estimate_beta_SI()`
      # return a negative estimate of susceptibles or infecteds?
      is_neg <- sapply(df_est,
        function(x) {
          sapply(x[c("S", "I")],
            function(y) {
              any(y < 0, na.rm = TRUE)
            }
          )
        }
      )

      # Warn if an estimate of susceptibles or infecteds is negative
      # and this hasn't already happened for an earlier `k`
      apply(
        expand.grid(c("S", "I"), c("S", "SI"), stringsAsFactors = FALSE), 1,
        function(x) {
          if (is_neg[x[1], x[2]] && !been_neg[x[1], x[2]]) {
            warning(
              par, "_log2f-",
              sprintf("%+05.0f", log(scale_factors[i], 2) * 1000),
              " ... ",
              x[2], " method returns `", x[1], "[i]` < 0 for some `i`",
              call. = FALSE
            )
          }
        }
      )

      # Update `been_neg` to reflect `is_neg`
      been_neg <- been_neg | is_neg

      ## 4. Fit loess curve to raw estimate ----------------------------

      # `loess()` handles `NA` but complains about `NaN` and `Inf`
      df_est <- lapply(df_est,
        function(x) {
          x$beta[is.nan(x$beta) | is.infinite(x$beta)] <- NA
          x
        }
      )

      # An unfortunate quirk in the implementation of `make_data()`
      # and `estimate_beta()`, which could be fixed with much effort:
      # When `trep` is underestimated, `estimate_beta()` fails and the
      # estimate `beta` consists entirely of `NA`. `loess()` throws an
      # error when it encounters this input, so we resort to `try()`.
      loess_fit <- mapply(
        function(x, y) {
          try(
            {
              stats::loess(
                formula   = beta ~ t,
                data      = x,
                span      = y / nrow(x),
                degree    = 2,
                na.action = "na.exclude",
                control   = stats::loess.control(
                  surface    = "direct",
                  statistics = "none"
                )
              )
            },
            silent = TRUE
          )
        },
        df_est, loess_par,
        SIMPLIFY = FALSE
      )

      ## 4. Compute RRMSE in loess estimate ----------------------------

      # Retain `NA` if susceptibles or infecteds were estimated
      # to be negative or if `loess()` failed earlier
      rrmse[i, par, k, ] <- mapply(
        function(x, y) {
          if (x || inherits(y, "try-error")) {
            return(NA)
          }
          compute_rrmse(df$beta, stats::predict(y))
        },
        apply(is_neg, 2, any), loess_fit
      )

    }

  }

}


## Output ==============================================================

attr(rrmse, "arg_list") <-
  as.list(environment())[names(formals(test_s2inpars))]
rrmse
}

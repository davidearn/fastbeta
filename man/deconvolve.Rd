\name{deconvolve}
\alias{deconvolve}
\title{Richardson-Lucy deconvolution}
\description{
Performs a modified Richardson-Lucy iteration for the purpose
of estimating incidence from reported incidence or mortality,
conditional on a reporting probability and on a distribution
of the time to reporting.
}
%\details{}
\usage{
deconvolve(x, prob = 1, delay = 1,
           start, tol = 1, iter.max = 20L, complete = FALSE)
}
\arguments{
\item{x}{a numeric vector of length \code{n} giving the number of
  infections or deaths reported during \code{n} observation intervals
  of equal duration.}
\item{prob}{a numeric vector of length \code{d+n} such that
  \code{prob[d+i]} is the probability that an infection during
  interval \code{i} is eventually reported.  \code{prob} of
  length 1 is recycled.}
\item{delay}{a numeric vector of length \code{d+1} such that
  \code{delay[j]} is the probability that an infection during
  interval \code{i} is reported during interval \code{i+j-1},
  given that it is eventually reported.  \code{delay} need
  not sum to 1 but must not sum to 0.}
\item{start}{a numeric vector of length \code{d+n} giving a starting
  value for the iteration.  \code{start[d+i]} estimates the expected
  number of infections during interval \code{i} that are eventually
  reported.  If missing, then a starting value is generated by padding
  \code{x} on the left and right with \code{d-d0} and \code{d0} zeros,
  choosing \code{d0=\link{which.max}(delay)-1}.}
\item{tol}{a tolerance indicating a stopping condition;
  see the reference.}
\item{iter.max}{the maximum number of iterations.}
\item{complete}{a logical flag indicating if the result should
  preserve successive updates to \code{start}.}
}
\value{
A list with elements:
\item{value}{the result of updating \code{start} \code{iter} times
  then dividing by \code{prob}.  If \code{complete = TRUE},
  then \code{value} is a \code{(d+n)}-by-\code{(iter+1)} matrix
  containing \code{start} and the \code{iter} successive updates,
  each divided by \code{prob}.}
\item{chisq}{the chi-squared statistic(s) corresponding to \code{value}.}
\item{iter}{the number of iterations performed.}
}
%\seealso{}
\references{
Goldstein, E., Dushoff, J., Ma, J., Plotkin, J. B., Earn, D. J. D.,
& Lipsitch, M. (2020).
Reconstructing influenza incidence by deconvolution of daily mortality
time series.
\emph{Proceedings of the National Academy of Sciences U. S. A.},
\emph{106}(51), 21825-21829.
\doi{10.1073/pnas.0902958106}
}
\examples{
\dontshow{ % for R_DEFAULT_PACKAGES=NULL
library(   stats, pos = "package:base", verbose = FALSE)
library(graphics, pos = "package:base", verbose = FALSE)
}
h <- function(x, a = 1, b = 1, c = 0) a * exp(-b * (x - c)^2)

set.seed(0)
n <- 250L
d <- 100L
delay <- diff(pgamma(0L:(d + 1L), 100, 2))
x <- rpois(n, h(seq(0, 30, length.out = n), 100, 0.1, 10))
y <- tabulate(rep.int(1L:n, x) +
              sample(0L:d, size = sum(x), replace = TRUE, prob = delay),
              n)
a <- which.max(delay) - 1L
start <- c(double(d - a), y, double(a))

## FIXME: want example with more than _zero_ iterations ...
str(D0 <- deconvolve(y, delay = delay, start = start, complete = FALSE))
str(D1 <- deconvolve(y, delay = delay, start = start, complete =  TRUE))

matplot(cbind(x, y, D0$dx[-(1L:d)]), ann = FALSE)
matplot(D1$dx[-(1L:d), ], ann = FALSE)
}

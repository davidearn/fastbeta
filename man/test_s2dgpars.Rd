\name{test_s2dgpars}
\alias{test_s2dgpars}
\title{Measure sensitivity to data-generating parameters}
\usage{
test_s2dgpars(
  pars_to_vary = c("tgen"),
  par_list_ref = make_par_list(),
  scale_factors = c(1),
  with_dem_stoch = FALSE,
  nsim = 4L,
  loess_par = c(NA, NA),
  only_make_data = FALSE
)
}
\arguments{
\item{pars_to_vary}{Character vector. Contains the names of all
data-generating parameters to be varied, chosen from \code{"S0"},
\code{"I0"}, \code{"nu"}, \code{"mu"}, \code{"tgen"}, and \code{"prep"}.}

\item{par_list_ref}{A list returned by
\code{make_par_list(..., beta_mean = NA, N0 = NA, S0 = NA, I0 = NA)}.
Contains reference values for all data-generating parameters.
The values listed for \code{Rnaught}, \code{N0}, \code{S0}, and \code{I0} are not
used when \code{nu}, \code{mu}, or \code{tgen} acts as the independent variable
in the analysis (see Details).}

\item{scale_factors}{Numeric vector. The values of \code{pars_to_vary[j]}
considered in the analysis are
\code{par_list_ref[[pars_to_vary[j]]] * scale_factors}.}

\item{with_dem_stoch}{Logical scalar, passed to \code{\link[=make_data]{make_data()}}. If
\code{TRUE}, then simulations account for demographic stochasticity.}

\item{nsim}{Integer scalar. The number of simulations to perform
using each parametrization.}

\item{loess_par}{Integer vector of length 2. Determines the degree
of smoothing when loess curves are fit to raw estimates of the
seasonally forced transmission rate (see Details). Estimates
generated by \code{\link[=estimate_beta_S]{estimate_beta_S()}} use \code{loess_par[1]}, while those
generated by \code{\link[=estimate_beta_SI]{estimate_beta_SI()}} use \code{loess_par[2]}.}

\item{only_make_data}{Logical scalar. If \code{TRUE}, then simulations
are performed and saved, as usual, but nothing more is done and
nothing is returned.}
}
\value{
Unless \code{only_make_data} is \code{TRUE}, a numeric array with dimensions
\code{c(length(scale_factors), length(pars_to_vary), nsim, 2)}. Stores
the relative root mean square error (RRMSE) in each estimate of the
data-generating, seasonally forced transmission rate. The
\verb{[i, j, k, m]}th entry corresponds to simulation \code{k} of \code{nsim} using
\code{par_vals_all[i, j]}, and estimate \code{m} of 2 from that simulation
(S method for \code{m = 1}, SI method for \code{m = 2}).

A list of the arguments of \code{test_s2dgpars()} is included as an
attribute.
}
\description{
\code{test_s2dgpars()} measures the sensitivity of transmission rate
estimation error to parameters used to simulate reported incidence
data. It varies the data-generating parameters \emph{one at a time}, and,
using each parametrization, it
(i) performs simulations,
(ii) estimates the data-generating, seasonally forced transmission
rate from the simulated data, without input error, and
(iii) records the estimation error.
Simulations are saved as \code{.RData} in the directory
\code{"./RData/s2dgpars/"}.
}
\details{
The space of data-generating parameters is sampled by assigning a
parameter in \code{pars_to_vary} its reference value in \code{par_list_ref}
multiplied by a scale factor in \code{scale_factors}, and assigning all
other parameters their reference value in \code{par_list_ref}. The total
number of parametrizations considered is thus given by
\code{length(pars_to_vary) * length(scale_factors)}. For each
parametrization
\ifelse{latex}{\out{$\mathbf{\theta}$}}{\ifelse{html}{\out{<b><i>&theta;</i></b>}}{theta}}:
\enumerate{
\item \code{\link[=make_data]{make_data()}} is called to simulate \code{nsim} reported incidence
time series, with arguments:
\itemize{
\item \code{par_list = par_list_dg}, indicating the data-generating
parameter values
\ifelse{latex}{\out{$\mathbf{\theta}$}}{\ifelse{html}{\out{<b><i>&theta;</i></b>}}{theta}}.
\item \code{n = 1042}, indicating the time series length.
\item \code{with_dem_stoch = with_dem_stoch}, indicating whether the
simulation should account for demographic stochasticity.
\item \code{seed = k}, where \code{k} is the simulation count out of \code{nsim},
making the result of each simulation reproducible.
}
\item \code{\link[=estimate_beta_S]{estimate_beta_S()}} and \code{\link[=estimate_beta_SI]{estimate_beta_SI()}} are called to
estimate the seasonally forced transmission rate from each
simulation, with arguments:
\itemize{
\item \code{df = df}, where \code{df} is the output of \code{\link[=make_data]{make_data()}},
supplying the simulated reported incidence time series.
\item \code{par_list = par_list_dg}, indicating the input parameter values
\ifelse{latex}{\out{$\mathbf{\xi}$}}{\ifelse{html}{\out{<b><i>&xi;</i></b>}}{xi}}.
There is no error in the input. In other words, the input
parameter values are identical to the data-generating
parameter values.
}

Mock (constant) birth and natural mortality time series are
created internally, with \code{B[i] = with(par_list, hatN0 * nu * 1)}
and \code{mu[i] = with(par_list, mu)} for all \code{i}.
\item \code{\link[stats:loess]{stats::loess()}} is called to fit a loess curve to each
raw estimate of the seasonally forced transmission rate,
with arguments
\itemize{
\item \code{formula = beta ~ t} and \code{data = df_est}, where \code{df_est} is
the output of \code{\link[=estimate_beta_S]{estimate_beta_S()}} or \code{\link[=estimate_beta_SI]{estimate_beta_SI()}},
indicating the time series to which the loess curve should
be fit.
\item \code{span = loess_par[i] / nrow(df_est)}, indicating (roughly)
the proportion of points to be weighted in local regression.
\item \code{degree = 2}, indicating that a quadratic polynomial should
be fit locally.
\item \code{na.action = "na.exclude"}, indicating that missing values
should be omitted in local regression but preserved in the
output of \code{\link[stats:predict]{stats::predict()}}.
}
\item \code{\link[=compute_rrmse]{compute_rrmse()}} is called to compute the error in each
loess estimate, with arguments
\itemize{
\item \code{x = df$beta}, indicating the true value of the transmission
rate at each observation time.
\item \code{y = predict(loess_fit)}, where \code{loess_fit} is the output
of \code{\link[stats:loess]{stats::loess()}}, indicating the estimated value of the
transmission rate at each observation time.
}
}

There is one caveat in the above description: as \code{nu}, \code{mu}, and
\code{tgen} vary, values for \code{Rnaught}, \code{N0}, \code{S0} and \code{I0} are \emph{not}
not taken from \code{par_list_ref}. As
\ifelse{latex}{\out{$\nu_\text{c}$}}{\ifelse{html}{\out{<i>&nu;<sub>c</sub></i>}}{nu_c}},
\ifelse{latex}{\out{$\mu_\text{c}$}}{\ifelse{html}{\out{<i>&mu;</i><sub>c</sub>}}{mu_c}},
and
\ifelse{latex}{\out{$t_\text{gen}$}}{\ifelse{html}{\out{<i>t</i><sub>gen</sub>}}{t_gen}}
vary,
\ifelse{latex}{\out{$\mathcal{R}_0$}}{\ifelse{html}{\out{<i>&Rscr;</i><sub>0</sub>}}{calR_0}}
varies concurrently in order to enforce the identity

\ifelse{latex}{\out{$\mathcal{R}_0 = \frac{\nu_\text{c} \widehat{N}_0}{\mu_\text{c}} \cdot \frac{\langle\beta\rangle}{\gamma + \mu}\,.$}}{\ifelse{html}{\out{<i>&Rscr;</i><sub>0</sub> = (<i>&nu;</i><sub>c</sub> <i>&Ntilde;</i> / <i>&mu;</i><sub>c</sub>)(&langle;<i>&beta;</i>&rangle; / (<i>&gamma;</i> + <i>&mu;</i><sub>c</sub>)).}}{calR_0 = ((nu_c*hatN0)/mu_c)*(<beta>/(gamma + mu)).}}

Similarly,
\ifelse{latex}{\out{$N_0$}}{\ifelse{html}{\out{<i>N</i><sub>0</sub>}}{N_0}},
\ifelse{latex}{\out{$S_0$}}{\ifelse{html}{\out{<i>S</i><sub>0</sub>}}{S_0}},
and
\ifelse{latex}{\out{$I_0$}}{\ifelse{html}{\out{<i>I</i><sub>0</sub>}}{I_0}}
vary concurrently in order to ensure that they specify a point very
near the attractor of the system of SIR equations. (The system and its
attractor change as functions of
\ifelse{latex}{\out{$\nu_\text{c}$}}{\ifelse{html}{\out{<i>&nu;<sub>c</sub></i>}}{nu_c}},
\ifelse{latex}{\out{$\mu_\text{c}$}}{\ifelse{html}{\out{<i>&mu;</i><sub>c</sub>}}{mu_c}},
and
\ifelse{latex}{\out{$t_\text{gen}$}}{\ifelse{html}{\out{<i>t</i><sub>gen</sub>}}{t_gen}}.)
}
